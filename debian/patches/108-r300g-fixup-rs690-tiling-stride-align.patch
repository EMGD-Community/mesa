From 32218e4cc88f7dedebadffe4a80247decf4498f1 Mon Sep 17 00:00:00 2001
From: Dave Airlie <airlied@redhat.com>
Date: Fri, 10 Dec 2010 15:40:48 +1000
Subject: [PATCH] r300g: fixup rs690 tiling stride alignment calculations.

The RS690 memory controller prefers things to be on a different
boundary than the discrete GPUs, we had an attempt to fix this,
but it still failed, this consolidates the stride calculation
into one place and removes the really special case check.

This fixes gnome-shell and 16 piglit tests on my rs690 system.

NOTE: This is a candidate for both the 7.9 and 7.10 branches.

Signed-off-by: Dave Airlie <airlied@redhat.com>
(cherry picked from commit d19b5cbd317620f3977e68fffb7a74793436b7e2)
---
 src/gallium/drivers/r300/r300_texture.c      |    2 +-
 src/gallium/drivers/r300/r300_texture_desc.c |   46 +++++++++----------------
 src/gallium/drivers/r300/r300_texture_desc.h |    2 +-
 3 files changed, 19 insertions(+), 31 deletions(-)

diff --git a/src/gallium/drivers/r300/r300_texture.c b/src/gallium/drivers/r300/r300_texture.c
index 70fc5d9..6d86bc2 100644
--- a/src/gallium/drivers/r300/r300_texture.c
+++ b/src/gallium/drivers/r300/r300_texture.c
@@ -899,7 +899,7 @@ struct pipe_surface* r300_create_surface(struct pipe_context * ctx,
                                                tex->desc.b.b.nr_samples,
                                                tex->desc.microtile,
                                                tex->desc.macrotile[level],
-                                               DIM_HEIGHT);
+                                               DIM_HEIGHT, 0);
 
         surface->cbzb_height = align((surface->base.height + 1) / 2,
                                      tile_height);
diff --git a/src/gallium/drivers/r300/r300_texture_desc.c b/src/gallium/drivers/r300/r300_texture_desc.c
index aa82c47..7b17391 100644
--- a/src/gallium/drivers/r300/r300_texture_desc.c
+++ b/src/gallium/drivers/r300/r300_texture_desc.c
@@ -34,7 +34,7 @@ unsigned r300_get_pixel_alignment(enum pipe_format format,
                                   unsigned num_samples,
                                   enum r300_buffer_tiling microtile,
                                   enum r300_buffer_tiling macrotile,
-                                  enum r300_dim dim)
+                                  enum r300_dim dim, boolean is_rs690)
 {
     static const unsigned table[2][5][3][2] =
     {
@@ -57,6 +57,7 @@ unsigned r300_get_pixel_alignment(enum pipe_format format,
             {{ 16, 8}, { 0,  0}, { 0,  0}}  /* 128 bits per pixel */
         }
     };
+
     static const unsigned aa_block[2] = {4, 8};
     unsigned tile = 0;
     unsigned pixsize = util_format_get_blocksize(format);
@@ -74,6 +75,14 @@ unsigned r300_get_pixel_alignment(enum pipe_format format,
     } else {
         /* Standard alignment. */
         tile = table[macrotile][util_logbase2(pixsize)][microtile][dim];
+        if (macrotile == 0 && is_rs690 && dim == DIM_WIDTH) {
+            int align;
+            int h_tile;
+            h_tile = table[macrotile][util_logbase2(pixsize)][microtile][DIM_HEIGHT];
+            align = 64 / (pixsize * h_tile);
+            if (tile < align)
+                tile = align;
+        }
     }
 
     assert(tile);
@@ -89,7 +98,7 @@ static boolean r300_texture_macro_switch(struct r300_texture_desc *desc,
     unsigned tile, texdim;
 
     tile = r300_get_pixel_alignment(desc->b.b.format, desc->b.b.nr_samples,
-                                    desc->microtile, R300_BUFFER_TILED, dim);
+                                    desc->microtile, R300_BUFFER_TILED, dim, 0);
     if (dim == DIM_WIDTH) {
         texdim = u_minify(desc->width0, level);
     } else {
@@ -113,6 +122,9 @@ static unsigned r300_texture_get_stride(struct r300_screen *screen,
                                         unsigned level)
 {
     unsigned tile_width, width, stride;
+    boolean is_rs690 = (screen->caps.family == CHIP_FAMILY_RS600 ||
+                        screen->caps.family == CHIP_FAMILY_RS690 ||
+                        screen->caps.family == CHIP_FAMILY_RS740);
 
     if (desc->stride_in_bytes_override)
         return desc->stride_in_bytes_override;
@@ -131,38 +143,14 @@ static unsigned r300_texture_get_stride(struct r300_screen *screen,
                                               desc->b.b.nr_samples,
                                               desc->microtile,
                                               desc->macrotile[level],
-                                              DIM_WIDTH);
+                                              DIM_WIDTH, is_rs690);
         width = align(width, tile_width);
 
         stride = util_format_get_stride(desc->b.b.format, width);
-
-        /* Some IGPs need a minimum stride of 64 bytes, hmm... */
-        if (!desc->macrotile[level] &&
-            (screen->caps.family == CHIP_FAMILY_RS600 ||
-             screen->caps.family == CHIP_FAMILY_RS690 ||
-             screen->caps.family == CHIP_FAMILY_RS740)) {
-            unsigned min_stride;
-
-            if (desc->microtile) {
-                unsigned tile_height =
-                        r300_get_pixel_alignment(desc->b.b.format,
-                                                 desc->b.b.nr_samples,
-                                                 desc->microtile,
-                                                 desc->macrotile[level],
-                                                 DIM_HEIGHT);
-
-                min_stride = 64 / tile_height;
-            } else {
-                min_stride = 64;
-            }
-
-            return stride < min_stride ? min_stride : stride;
-        }
-
         /* The alignment to 32 bytes is sort of implied by the layout... */
         return stride;
     } else {
-        return align(util_format_get_stride(desc->b.b.format, width), 32);
+        return align(util_format_get_stride(desc->b.b.format, width), is_rs690 ? 64 : 32);
     }
 }
 
@@ -179,7 +167,7 @@ static unsigned r300_texture_get_nblocksy(struct r300_texture_desc *desc,
                                                desc->b.b.nr_samples,
                                                desc->microtile,
                                                desc->macrotile[level],
-                                               DIM_HEIGHT);
+                                               DIM_HEIGHT, 0);
         height = align(height, tile_height);
 
         /* This is needed for the kernel checker, unfortunately. */
diff --git a/src/gallium/drivers/r300/r300_texture_desc.h b/src/gallium/drivers/r300/r300_texture_desc.h
index 44d8879..121d215 100644
--- a/src/gallium/drivers/r300/r300_texture_desc.h
+++ b/src/gallium/drivers/r300/r300_texture_desc.h
@@ -41,7 +41,7 @@ unsigned r300_get_pixel_alignment(enum pipe_format format,
                                   unsigned num_samples,
                                   enum r300_buffer_tiling microtile,
                                   enum r300_buffer_tiling macrotile,
-                                  enum r300_dim dim);
+                                  enum r300_dim dim, boolean is_rs690);
 
 boolean r300_texture_desc_init(struct r300_screen *rscreen,
                                struct r300_texture_desc *desc,
-- 
1.7.2.3

