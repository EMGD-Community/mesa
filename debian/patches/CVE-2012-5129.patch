Backport of:

From 46e3aeb07702f57d389fbfcade9d4ef66218dc53 Mon Sep 17 00:00:00 2001
From: Frank Henigman <fjhenigman@google.com>
Date: Fri, 14 Dec 2012 20:52:17 +0000
Subject: mesa: add bounds checking for uniform array access

No piglit regressions and now passes glsl-uniform-out-of-bounds-2.

validate_uniform_parameters now checks that the array index is
valid.  This means if an index is out of bounds, glGetUniform* now
fails with GL_INVALID_OPERATION, as it should.
_mesa_uniform and _mesa_uniform_matrix also call
validate_uniform_parameters so the bounds checks there became
redundant and were removed.

The test in glGetUniformLocation is modified to check array bounds
so it now returns GL_INVALID_INDEX (-1) if you ask for the location
of a non-existent array element, as it should.

Signed-off-by: Frank Henigman <fjhenigman@google.com>
Reviewed-by: St√©phane Marchesin <marcheu@chromium.org>
---
(limited to 'src/mesa/main/uniform_query.cpp')

Index: mesa-8.0.4/src/mesa/main/uniform_query.cpp
===================================================================
--- mesa-8.0.4.orig/src/mesa/main/uniform_query.cpp	2013-04-30 15:01:27.341893214 -0700
+++ mesa-8.0.4/src/mesa/main/uniform_query.cpp	2013-04-30 15:02:24.981894690 -0700
@@ -164,11 +164,14 @@
       return false;
    }
 
-   /* This case should be impossible.  The implication is that a call like
-    * glGetUniformLocation(prog, "foo[8]") was successful but "foo" is not an
-    * array.
-    */
-   if (*array_index != 0 && shProg->UniformStorage[*loc].array_elements == 0) {
+   /* If the uniform is an array, check that array_index is in bounds.
+    * If not an array, check that array_index is zero.
+    * array_index is unsigned so no need to check for less than zero.
+    */
+   unsigned limit = shProg->UniformStorage[*loc].array_elements;
+   if (limit == 0)
+      limit = 1;
+   if (*array_index >= limit) {
       _mesa_error(ctx, GL_INVALID_OPERATION, "%s(location=%d)",
 		  caller, location);
       return false;
@@ -655,9 +658,6 @@
     * will have already generated an error.
     */
    if (uni->array_elements != 0) {
-      if (offset >= uni->array_elements)
-	 return;
-
       count = MIN2(count, (int) (uni->array_elements - offset));
    }
 
@@ -801,9 +801,6 @@
     * will have already generated an error.
     */
    if (uni->array_elements != 0) {
-      if (offset >= uni->array_elements)
-	 return;
-
       count = MIN2(count, (int) (uni->array_elements - offset));
    }
 
@@ -933,10 +930,13 @@
    if (!found)
       return -1;
 
-   /* Since array_elements is 0 for non-arrays, this causes look-ups of 'a[0]'
-    * to (correctly) fail if 'a' is not an array.
+   /* If the uniform is an array, fail if the index is out of bounds.
+    * (A negative index is caught above.)  This also fails if the uniform
+    * is not an array, but the user is trying to index it, because
+    * array_elements is zero and offset >= 0.
     */
-   if (array_lookup && shProg->UniformStorage[location].array_elements == 0) {
+   if (array_lookup
+	 && offset >= shProg->UniformStorage[location].array_elements) {
       return -1;
    }
 
